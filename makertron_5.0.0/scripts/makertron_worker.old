// ==========================================================
// MAKERTRON Procedural Cad System  
// Damien V Towning 
// 2016

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL Damien Towning BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// ==========================================================

var csgProcess = (function () {
  
	"use strict";

 /*global $,widgets,window,CSG,document,makertron*/
 /*jshint -W069 */
	
	
	importScripts('three/three.js');
	importScripts('base64.js'); 
	importScripts('binarystlwriter.js'); 
	importScripts('blob_util.js'); 
	importScripts('socket.io.js'); 
	importScripts('core/lodash.min.js') 
	importScripts('async.js') 
	importScripts('pako.min.js')

	 // Pull server address here because no dom for sessionKeys 
  importScripts("config.js"); 
  var SERVER_ADDRESS = CONFIG_DATA.SERVER_ADDRESS + ":" + CONFIG_DATA.PORT; 
	
	//var socket_send = function(send,send_data) { socket.emit( send, send_data ) }
	//var socket_recv = function( recv , wrker , callback ) { socket.on(recv, function(data){ wrker(data,callback) }) }

	var parse_data = new function() { 
		this.csgObjects = [] 
		this.function_set = [] 
		this.function_index = 0 

	 	this.push = function( obj) { 
  		this.csgObjects.push(obj)
		}
		this.next = function() { 
			update() 
    	this.function_index++
  	}
		this.fetch = function() { 
			return this.function_set[this.function_index]
		}
	}

	// --------------------------------------------------------
	// Generate a hashed string
	// --------------------------------------------------------
	var makeId = function() {
		var text = "";
		var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		for( var i=0; i < 5; i++ )
		text += possible.charAt(Math.floor(Math.random() * possible.length));
		return text;
	};

	// ===============================================
	// Decode base64 field 
	// ===============================================
	var decodeBase64 = function(text) { 
		var head = "[@base64>"
		var tail = "<base64@]"
		var a = text.substr(0,head.length);  
		var b = text.substr(text.length-tail.length,text.length) 
		if ( a === head && b === tail ) { 
			return Base64.decode(text.substr( head.length , text.length-tail.length-head.length )) 
		}
		else { 
			return text			
		}			
	}
	
	// ===============
	// return radians 
	// ===============
	var radians=function(deg) { 
		return deg * (Math.PI / 180);
	};

	//=================
	// return degree's 
	// ================
	var degree=function(rad) { 
		return rad / (Math.PI / 180); 
	};
	
	// ===================================================
	// Return attribute or its default 
	// ===================================================
	var create_default = function( attrib , def ) { 
		if ( attrib === undefined ) return def 
		return attrib  
	}
	
	// ===================================================
	// Set state of object with parsing for dirty state
	// ===================================================
	var check_state = function(state) { 
		if ( state !== 0 && state !== false || state === 1 ) { state = true; } else { state = false; }
		return state; 
	};

	// ================================================================
	// Output vertices/face list ( off ) for handing to OpenSCAD
	// =================================================================			
	var condensed_off = function(object) { 
		var i = 0; 
		var ii = 0; 
		var foo = [];
		var vertices = [];
		var new_face = {}; 
		var new_faces = []; 
		// Decompose current matrix of object since we want true position rotation scale in space etc  
		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();
		object.updateMatrixWorld();
		object.matrixWorld.decompose( position, quaternion, scale );	
		var points = object.geometry.vertices; 
		var faces = object.geometry.faces; 
		var points_length = points.length; 
		var faces_length = faces.length; 
		var a
		var b
		var c
		// construct vertice list with no duplicates 
		foo = foo.concat( points.map( function (item) { return item.clone(); })); // map us to a plain array   	
		for ( i = 0; i < points_length; i++ ) { 
			if ( foo[i].s === true ) { 
				a = foo[i].cloneS();
				vertices.push( a ); 
				for ( ii = 0; ii < points_length; ii++ ) { 
					if ( i!=ii ) { 
						b = foo[ii].cloneS();
						if ( a.equals(b) ) { foo[ii].s = false; }
					}
				}
			}
		}				
		// reduce vertice list and remap face indices to that list. This is what makes us compatible with cork. Brute Force.  
		var vertices_length = vertices.length; 
		for ( i = 0; i < faces_length; i++ ) { 
			// pick up the vertices 
			a = points[faces[i].a]; 
			b = points[faces[i].b]; 
			c = points[faces[i].c]; 
			// face indices if we fail to index
			new_face = {a:-1,b:-1,c:-1};
			// now hunt it in the reduced vertice list! 
			for ( ii = 0; ii < vertices_length; ii++ ) { 
				if ( a.equals(vertices[ii])) { new_face.a = ii; }
				if ( b.equals(vertices[ii])) { new_face.b = ii; }
				if ( c.equals(vertices[ii])) { new_face.c = ii; }
			}
			if ( new_face.a === -1 || new_face.b === -1 || new_face.c === -1 ) { 	postMessage( ["console", "Indice error!" ] ); } 
			new_faces.push( new_face ); 
		}
		// pull out vertices 
		var new_faces_length = new_faces.length; 
		var v = []; 
		var f = []; 
		for ( i = 0; i < vertices_length; i++ ) { 
			vertices[i].add( position ); // multiplying by position vector 
			vertices[i].applyQuaternion( quaternion ); // Applying rotation 
			// scale?
			//console.log( 'vertices',vertices[i] ) 
			v.push(  vertices[i].x , vertices[i].y , vertices[i].z ); 
		}
		// pull out faces
		for ( i = 0; i < new_faces_length; i++ ) { 
			//f.push( new_faces[i].a , new_faces[i].b , new_faces[i].c ); // a b c 
			f.push( new_faces[i].c , new_faces[i].b , new_faces[i].a ); // c b a 
		}
		return [v,f]; 
	}

	// ===============================================
	// Auto generate UV's 
	// ===============================================
	var assignUVs = function( geometry ){
    //geometry.computeBoundingBox();
    var max     = geometry.boundingBox.max;
    var min     = geometry.boundingBox.min;
    var offset  = new THREE.Vector2(0 - min.x, 0 - min.y);
    var range   = new THREE.Vector2(max.x - min.x, max.y - min.y);
    geometry.faceVertexUvs[0] = [];
    var faces = geometry.faces;
    for (var i = 0; i < geometry.faces.length ; i++) {
      var v1 = geometry.vertices[faces[i].a];
      var v2 = geometry.vertices[faces[i].b];
      var v3 = geometry.vertices[faces[i].c];
      geometry.faceVertexUvs[0].push([
        new THREE.Vector2( ( v1.x + offset.x ) / range.x , ( v1.y + offset.y ) / range.y ),
        new THREE.Vector2( ( v2.x + offset.x ) / range.x , ( v2.y + offset.y ) / range.y ),
        new THREE.Vector2( ( v3.x + offset.x ) / range.x , ( v3.y + offset.y ) / range.y )
      ]);
    }
    geometry.uvsNeedUpdate = true;
	};


	var assignUVs2 = function(geometry) {
    geometry.faceVertexUvs[0] = [];
    geometry.faces.forEach(function(face) {
        var uvs = [];
        var ids = [ 'a', 'b', 'c'];
        for( var i = 0; i < ids.length; i++ ) {
            var vertex = geometry.vertices[ face[ ids[ i ] ] ].clone();
            var n = vertex.normalize();
            var yaw = .5 - Math.atan( n.z, - n.x ) / ( 2.0 * Math.PI );
            var pitch = .5 - Math.asin( n.y ) / Math.PI;
            var u = yaw, v = pitch;
            uvs.push( new THREE.Vector2( u, v ) );
        }
        geometry.faceVertexUvs[ 0 ].push( uvs );
    });
    geometry.uvsNeedUpdate = true;
	}

	// ================================================
	// Draw a curved cylinder along a path 
	// ================================================
	var curvedBeast = function(r1,r2,slices,points) { 
		if((r2 < 0) || (r1 < 0)) {
			throw new Error("Radius should be non-negative");
		}
		if((r2 === 0) && (r1 === 0)) {
			throw new Error("Either radiusStart or radiusEnd should be positive");
		}
		var axisZ = new THREE.Vector3(); 
		var axisX = new THREE.Vector3();		
		var axisY = new THREE.Vector3(); 
		// Get distance between two vectors
		var get_distance = function( vec_a , vec_b ) { 
			var p_a = new THREE.Vector3().fromArray(vec_a);
			var p_b = new THREE.Vector3().fromArray(vec_b);
			return	p_a.distanceTo(p_b); 
		};
		// point on circle
		function point(stack, slice, radius) {
			var angle = slice * Math.PI * 2;
			var out   = new THREE.Vector3().copy(axisX); 
			var at    = new THREE.Vector3().copy(axisY); 
			out.multiplyScalar( Math.cos(angle)).add( at.multiplyScalar(Math.sin(angle)) );
			var pos = new THREE.Vector3().copy(s); 
			var r   = new THREE.Vector3().copy(ray); 
			pos.add(r.multiplyScalar(stack)).add(out.multiplyScalar(radius));
			return pos; 
		}	
		var randomNonParallelVector = function(vec) {
			var abs = new THREE.Vector3(Math.abs(vec.x), Math.abs(vec.y), Math.abs(vec.z));
			if((abs.x <= abs.y) && (abs.x <= abs.z)) {
				return new THREE.Vector3(1, 0, 0);
			} else if((abs.y <= abs.x) && (abs.y <= abs.z)) {
				return new THREE.Vector3(0, 1, 0);
			} else {
				return new THREE.Vector3(0, 0, 1);
			}
		};
		var segments = [];  // segments 
		var dist     = 0.0; // distance
		var m        = 0.0; // slope 
		var rdist    = 0.0;   
		// Take our points turn to segments 
		for ( var i = 0; i < points.length - 2; i+=2 ) { 
			var segment = []; 
			segment.p_a = [ points[i]   ,  points[i+1] , 0 ];
			segment.p_b = [ points[i+2] ,  points[i+3] , 0 ];
			segment.rad_a = r1; 
			segment.rad_b = r1; 
			dist = dist + get_distance( segment.p_a , segment.p_b ); 
			segments.push( segment );
		}
		
		// Slope across segments 
		if ( r1 !== r2 ) {  
			if ( r2 < r1 ) {  m =  ( r1 - r2 ) / dist; }
			if ( r2 > r1 ) {  m =  ( r2 - r1 ) / dist; }
			for (  i = 0; i < segments.length; i++ ) { 
				var vec_a = segments[i].p_a; 
				var vec_b = segments[i].p_b;    
				if ( i === 0 ) {
					segments[i].rad_a = r1;
					if ( r2 < r1 ) { 	
						rdist = dist - get_distance(vec_a,vec_b);
						segments[i].rad_b = ( m * rdist )+ r2; 
					}
					else { 
						rdist = get_distance(vec_a,vec_b);
						segments[i].rad_b = ( m * rdist )+ r1; 
					}
				}
				else {  
					segments[i].rad_a = segments[i-1].rad_b;
					if ( r2 < r1 ) { 
						rdist = rdist - get_distance(vec_a,vec_b);
						segments[i].rad_b = ( m * rdist )+r2;
					}
					else { 
						rdist = rdist + get_distance(vec_a,vec_b);
						segments[i].rad_b = ( m * rdist )+r1;
					}
				}
			}
		}	
		var polygons = new THREE.Geometry();
		var top_cap  = [];
		var end_cap  = []; 
		var prev_cap = []; 
		var nonconvex = false; 
    var a_b = [];
	  var a_c = [];	
		var b_b = [];
		var b_c = [];
		var fc = 0; 
		for ( var j = 0; j < segments.length; j++ ) {	
			var s = new THREE.Vector3().fromArray(segments[j].p_a);
			s.setY(  s.y*= -1 ); // invert y axis to match bezier tool  
			var e = new THREE.Vector3().fromArray(segments[j].p_b);	
			e.setY(  e.y*= -1 ); // invert y axis to match bezier tool 
			var ray = new THREE.Vector3().copy(e); 
			ray.sub(s);
			axisZ.copy(ray); axisZ.normalize();  //, isY = (Math.abs(axisZ.y) > 0.5);
			axisX = randomNonParallelVector(axisZ); axisX.normalize();
			axisY.copy(axisX);  axisY.cross(axisZ).normalize();
			var start = new THREE.Vector3().copy(s); // start pipe segment 
			var end   = new THREE.Vector3().copy(e); // end pipe segment 
			var rStart = segments[j].rad_a; // start pipe radius 
			var rEnd =   segments[j].rad_b; // end pipe radius 
			top_cap = [];
			end_cap = []; 
			for( i = 0; i < slices; i++) {
				var t0 = i / slices,
				t1 = (i + 1) / slices;
				if(rEnd === rStart) {
					top_cap.push([start, point(0, t0, rEnd), point(0, t1, rEnd)] );
					end_cap.push([end  , point(1, t1, rEnd), point(1, t0, rEnd)] );			
				} else {
					if(rStart > 0) {
						top_cap.push([start, point(0, t0, rStart), point(0, t1, rStart)]);
					}
					if(rEnd > 0) {
						end_cap.push([end, point(1, t1, rEnd), point(1, t0, rEnd)]);
					}
				}
			}
			for ( var ii = 0; ii < top_cap.length; ii++ ) { 			
				if ( j === 0 ) { 
					polygons.vertices.push( top_cap[ii][0] ); 
					polygons.vertices.push( top_cap[ii][1] ); 
					polygons.vertices.push( top_cap[ii][2] ); 
					polygons.faces.push( new THREE.Face3( fc+0, fc+1, fc+2 ) ); fc+=3; 
				}
				else { 
					a_b = prev_cap[ii][1];
					a_c = prev_cap[ii][2];
					b_b = top_cap[ii][1];
					b_c = top_cap[ii][2];
					polygons.vertices.push(b_c,a_c,a_b);
					polygons.faces.push( new THREE.Face3( fc+0, fc+1, fc+2 ) ); fc+=3;
					polygons.vertices.push(b_c,a_b,b_b);
					polygons.faces.push( new THREE.Face3( fc+0, fc+1, fc+2 ) ); fc+=3;
				}
				if ( j === segments.length-1 ) {
					a_b = top_cap[ii][2];
				  a_c = top_cap[ii][1];	
					b_b = end_cap[ii][1];
				  b_c = end_cap[ii][2];	
					polygons.vertices.push(a_b,a_c,b_c);
					polygons.faces.push( new THREE.Face3( fc+0, fc+1, fc+2 ) ); fc+=3;
					polygons.vertices.push(b_b,a_b,b_c);
					polygons.faces.push( new THREE.Face3( fc+0, fc+1, fc+2 ) ); fc+=3;
					polygons.vertices.push(end_cap[ii][0],end_cap[ii][1],end_cap[ii][2]);
					polygons.faces.push( new THREE.Face3( fc+0, fc+1, fc+2 ) ); fc+=3;
				}
			}
			prev_cap = top_cap; 
		}	
		polygons.mergeVertices();
		polygons.computeBoundingBox();
		polygons.computeFaceNormals();
		polygons.computeVertexNormals(); 
		assignUVs(polygons); 
		return polygons; 
	};

  // ==========================================================
	// Generate three sphere 
	// ==========================================================
	var sphere = function(callback) {
		postMessage( ["console", "sphere" + parse_data.fetch() ] );
		var name       = create_default( parse_data.fetch().name       ,  "unamed" + makeId() ); 
		var group      = create_default( parse_data.fetch().group      ,  1             ); 
		var color      = create_default( parse_data.fetch().color      ,  [ 1 , 1 , 1 ] ); 	
		var rot        = create_default( parse_data.fetch().rot        ,  [ 0 , 0 , 0 ] );  
		var pos    		 = create_default( parse_data.fetch().pos	       ,  [ 0 , 0 , 0 ] ); 
		var radius 		 = create_default( parse_data.fetch().radius     ,  1             ); 
		var scale      = create_default( parse_data.fetch().scale      ,  [ 1 , 1 , 1 ] ); 
		var resolution = create_default( parse_data.fetch().resolution ,  8             ); 
		var state 		 = check_state(create_default( parse_data.fetch().state     ,  1  )); 
		var msh = new THREE.SphereGeometry( radius , resolution , resolution );
		var obj = new THREE.Mesh(msh,new THREE.MeshNormalMaterial());	
		obj.scale.set( scale[0] , scale[1] , scale[2] ); 
		obj.rotation.set( radians(rot[0]) , radians(rot[1]) , radians(rot[2]) ); 
		obj.position.set( pos[0] , pos[1] , pos[2] ); 
		obj.name =  name; 
		obj.group = group; 
		obj.state = state; 
		//obj.color = color;  
		obj.extras = [];  
		parse_data.push( obj ) 
		parse_data.next() 
		callback(null, obj);  
	}

	// ============================================================
	// Generate three cube 
	// ============================================================
	var cube = function(callback) {
		postMessage( ["console", "cube" + parse_data.fetch() ] );
		var name       = create_default( parse_data.fetch().name       , "unamed" + makeId() ); 
		var group      = create_default( parse_data.fetch().group      ,   1           ); 
		var color      = create_default( parse_data.fetch().color      , [ 1 , 1 , 1 ] ); 	
		var rot        = create_default( parse_data.fetch().rot        , [ 0 , 0 , 0 ] );  
		var pos    		 = create_default( parse_data.fetch().pos	       , [ 0 , 0 , 0 ] ); 
		var radius 		 = create_default( parse_data.fetch().radius     ,   1           ); 
		var scale      = create_default( parse_data.fetch().scale      , [ 1 , 1 , 1 ] ); 
		var resolution = create_default( parse_data.fetch().resolution ,   8           ); 
		var state 		 = check_state(create_default( parse_data.fetch()     ,  1  )); 
		var msh = new THREE.BoxGeometry( radius[0], radius[1], radius[2] );
		var obj = new THREE.Mesh(msh,new THREE.MeshNormalMaterial());
		obj.scale.set( scale[0] , scale[1] , scale[2] ); 
		obj.rotation.set( radians(rot[0]) , radians(rot[1]) , radians(rot[2]) ); 
		obj.position.set( pos[0] , pos[1] , pos[2] ); 
		obj.name =  name; 
		obj.group = group; 
		obj.state = state; 
		obj.color = color;  
		obj.extras = [];  
		parse_data.push( obj ) 
		parse_data.next() 
		callback(null,obj) 
	}

	var bezier = function(callback) {
		postMessage( ["console", "bezier" + parse_data.fetch() ] );	
		var name       = create_default( parse_data.fetch().name       , "unamed" + makeId() ); 
		var group      = create_default( parse_data.fetch().group      ,   1           ); 
		var color      = create_default( parse_data.fetch().color      , [ 1 , 1 , 1 ] ); 	
		var rot        = create_default( parse_data.fetch().rot        , [ 0 , 0 , 0 ] );  
		var pos    		 = create_default( parse_data.fetch().pos	       , [ 0 , 0 , 0 ] ); 
		var radius 		 = create_default( parse_data.fetch().radius     ,   1           ); 
		var scale      = create_default( parse_data.fetch().scale      , [ 1 , 1 , 1 ] ); 
		var controls   = create_default( parse_data.fetch().points     , [           ] );
		var resolution = create_default( parse_data.fetch().resolution ,   8           ); 
		var state 		 = check_state(create_default( parse_data.fetch().state     ,  1  ));
		var x1 = controls[0]; var y1 = controls[1]; 
		var x2 = controls[2]; var y2 = controls[3]; 
		var x3 = controls[4]; var y3 = controls[5]; 
		var x4 = controls[6]; var y4 = controls[7]; 
		//Generating curve		
		var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x1,y1),new THREE.Vector2(x2,y2),new THREE.Vector2(x3,y3), new THREE.Vector2(x4,y4));
		var path = new THREE.Path(curve.getPoints(10));
		var geometry = path.createPointsGeometry(10);
		// Bringing the path back to zero origin ... 	
		var i = 0		
		var points = []
		var xo = geometry.vertices[0].x;
		var yo = geometry.vertices[0].y; 
		var vert_length = geometry.vertices.length; 
		for ( i = 0; i < vert_length; i++ ) { 
			points.push( geometry.vertices[i].x - xo );
			points.push( geometry.vertices[i].y - yo );
		}
		// create bezier
		var od = new THREE.Mesh( new curvedBeast( radius[0] , radius[1] , resolution , points) , new THREE.MeshNormalMaterial()); 
		od.rotation.set( radians(rot[0]) , radians(rot[1]) , radians(rot[2]) ); 
		od.position.set(  pos[0] , pos[1] , pos[2] ); 
		od.updateMatrixWorld();
		od.name = name; 
		od.group = group; 
		od.state = state;
		od.color = color; 
		od.extras = [];  
		parse_data.push( od ) 
		parse_data.next() 
		callback(null,od) 
	}

	// ====================================
  // enable object/objects 
  // ====================================
	var enable = function(callback) { 
			postMessage( ["console", "enable" + parse_data.fetch() ] );
		var i = 0; 
		var ii = 0;   
		var names = parse_data.fetch().objects.split(",");
		var names_length = names.length; 
		var csgobjects_length = parse_data.csgObjects.length;
		for ( i = 0; i < names_length; i++ ) { 
			for ( ii = 0; ii < csgobjects_length; ii++ ) { 
				if ( names[i] === parse_data.csgObjects[ii].name ) parse_data.csgObjects[ii].state = true 			
			}
		}
		parse_data.next() 
		callback(null,"enabled") 
	}

	// ====================================
  // disable object/objects 
  // ====================================
	var disable = function(callback) { 
			postMessage( ["console", "disable" + parse_data.fetch() ] ); 
		var i = 0; 
		var ii = 0;   
		var names = parse_data.fetch().objects.split(",");
		var names_length = names.length; 
		var csgobjects_length = parse_data.csgObjects.length;
		for ( i = 0; i < names_length; i++ ) { 
			for ( ii = 0; ii < csgobjects_length; ii++ ) { 
				if ( names[i] === parse_data.csgObjects[ii].name ) parse_data.csgObjects[ii].state = false 			
			}
		}
		parse_data.next() 
		callback(null,"disabled") 
	}
	
	var error = function( data  , callback ) { 
			postMessage( ["console", "Error" + data ] ); 
			parse_data.next() 
			callback(null,[]) 
	}

	// ========================================================
	// convert stl in string and retun back vertices / faces 
	// ========================================================
	var buffer_stl = function(data) { 
		var vertices = []; 
		var face_length = 0; 
		var faces = []; 
		var i = 0; 
		var ii = 0; 
		data = data.split("||messages||"); 
		vertices = JSON.parse("["+data[0].toString()+"]");
		//logger( data ); 
		//vertices = JSON.parse("["+data.toString()+"]");
		return { "vertices" : vertices , "messages": JSON.stringify(data[1]) };  // We only return vertices because face list is stl incremental 
	}

	// ==============================
	// Random color 
	// ==============================
	function getRandomColor() {
    var letters = '0123456789ABCDEF';
    var color = '0x';
    for (var i = 0; i < 6; i++ ) {
        color += letters[Math.floor(Math.random() * 16)];
    }
		
    return color;
	}

	var openscad = function(callback) {		
			postMessage( ["console", "openscad" + parse_data.fetch() ] ); 
			var i = 0; 
			var name       = create_default( parse_data.fetch().name       , "unamed" + makeId() ) 
			var color      = create_default( parse_data.fetch().color      , [ 1 , 0 , 0 ] ) 	
			var state 		 = check_state(create_default( parse_data.fetch().state     ,  1  ))
			var result       = create_default( parse_data.fetch().result   , "unamed" + makeId() ) 
			// List of externally generated three objects
			var objects = []; 
			var object_length = parse_data.csgObjects.length; 
			for ( i = 0; i < object_length; i++ ) { 	
				var m = condensed_off(parse_data.csgObjects[i]); 
				objects.push( { "name":parse_data.csgObjects[i].name,"vertices": m[0].toString() , "faces" : m[1].toString() } )  
			}			

			var SESSIONKEY = makeId()+makeId()
			var socket = io(SERVER_ADDRESS)

			socket.emit( 'OPENSCAD', { 
																"objects":  objects , 
																	"scad" : { 
																		"name":  parse_data.fetch().name , 
																		"code" : parse_data.fetch().code , 
																		"res" :  parse_data.fetch().result 
																	},
																"hash" : SESSIONKEY
																} ) 

			socket.on( 'connect_error' , function(err){
				if ( err === 'timeout' ) 	postMessage( ["console", "wakeup!" ] ); 
			}) 		
			
			socket.on( 'OPENSCADRES'+SESSIONKEY ,  function(data){ 

				//var data = data.split("||messages||")		
				//var inflated = (pako.inflate(atob(data), { to: 'string' })).split(",");
				var inflated = data.split(",");
				var i = 0; 
				var v = inflated.map( function(a) { return parseFloat(a); });
				var f = []; 
				for ( i = 0; i < v.length/3; i++ ) { f[i] = i; } // since came from stl face list always incremental 					
				var vertices_length = v.length; 
				var faces_length = f.length; 
				var geometry = new THREE.Geometry();
				for ( i = 0; i < vertices_length-1; i+=3 ) { geometry.vertices.push( new THREE.Vector3( v[i+0],v[i+1],v[i+2] )); }
				for ( i = 0; i < faces_length-1; i+=3 ) {  geometry.faces.push( new THREE.Face3(f[i+0],f[i+1],f[i+2])); }
				geometry.computeBoundingBox();
				assignUVs( geometry ) 
			
				var new_obj = new THREE.Mesh( geometry ,new THREE.MeshNormalMaterial() );
			
				new_obj.name =  result; 
				new_obj.color = getRandomColor();   
				new_obj.state = state;
				new_obj.extras = [];		
				parse_data.push( new_obj ) 
				parse_data.next()
				callback(null,"done")
			})

			socket.on( 'OPENSCADMSG'+SESSIONKEY ,  function(msg){ 
				postMessage( ["console", msg ] );
			})

	}

	var update = function() { 
		var json = [];
		parse_data.csgObjects.forEach(function(object){
			if ( object.state === true ) { 
				if ( object.extras.length === 0 ) {   
					json.push( object.toDamien() ); 
				}
				else { json.push([object.extras]) } 
			}
		});
		postMessage( ["done",json] );
	}

	// Output our scene to the renderer 
	onmessage = function(e) {
		var i = 0
		var attributes   = {}
		// first build attributes list and function set 		
		e.data[1].forEach(function(jsn){
			jsn.object.forEach(function(obj){
				if ( obj.type === "openscad" ) { // must occur -before- function_set.push 
					obj.code = decodeBase64(obj.code)
				}
				if ( obj.type === "set" ) { 
					var operation = obj.operation.split("|"); // error checking needed here
					if ( operation[0] === 'range'   ) attributes[obj.value] = operation[3]
					if ( operation[0] === 'spinner' ) attributes[obj.value] = operation[3]
					if ( operation[0] === 'bezier'  ) attributes[obj.value] = operation[1] 
					if ( operation[0] === 'color' || operation[0] === 'colour' ) attributes[obj.value] = "["+[operation[1],operation[2],operation[3]]+"]"					
				} 
				if ( obj.type !== "panel" && obj.type !== "include" && obj.type !== 'set' ) {
						parse_data.function_set.push( obj ) 
				}		
			}); 				
		});			

		// now search and replace every other occurence -in- the script of a variable with a value. This is a simple string replace.  
		var keys = Object.keys(attributes) 
		var keys_length = keys.length 
		parse_data.function_set = JSON.stringify(parse_data.function_set) 
		for ( i = 0; i < keys_length; i++ ) { 
			parse_data.function_set = _.replace(parse_data.function_set,new RegExp(keys[i],"g"),attributes[keys[i]]) 
		}
		parse_data.function_set = JSON.parse( parse_data.function_set ) 
			
		parse_data.function_set.forEach(function(jsn){
			if ( jsn.pos         !== undefined ) jsn.pos         = eval(jsn.pos)
			if ( jsn.rot         !== undefined ) jsn.rot         = eval(jsn.rot) 
			if ( jsn.scale       !== undefined ) jsn.scale       = eval(jsn.scale)
			if ( jsn.radius      !== undefined ) jsn.radius      = eval(jsn.radius)
			if ( jsn.color       !== undefined ) jsn.color       = eval(jsn.color) 
			if ( jsn.resolution  !== undefined ) jsn.resolution  = eval(jsn.resolution) 
			if ( jsn.points      !== undefined ) jsn.points      = eval(jsn.points) 
		}); 

		var blob = {} 

		for ( i = 0; i < parse_data.function_set.length; i++ ) { 
			var funk = parse_data.function_set[i] 
			if ( funk.type === 'sphere'  ) { blob[makeId()] = sphere   }
			if ( funk.type === 'cube'    ) { blob[makeId()] = cube     }
			if ( funk.type === 'bezier'  ) { blob[makeId()] = bezier   }
			if ( funk.type === 'enable'  ) { blob[nakeId()] = enable   }
			if ( funk.type === 'disable' ) { blob[makeId()] = disable  }
			if ( funk.type === 'openscad') { blob[makeId()] = openscad }	
		}

		async.series( blob , function(err, results) { update() })
	  	
	}


	 
 

  
	return {
		onmessage: function(e) { 
			onmessage(e); 
		}
	};
 
}());

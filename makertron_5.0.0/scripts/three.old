	// ------------------------------------------------------
	// Three Module 
	// ------------------------------------------------------

	'use strict'

	import React from 'react';
	import ReactDOM from 'react-dom';

	var dark_primary_color  = "#303F9F" 
	var primary_width = '95vw' 
	var secondary_width = '94vw' 
	var canvas_width = '93.2vw'

	//var texture = new THREE.TextureLoader().load( 'resource/imgs/UV_Grid_Sm.jpg' );
	//texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
	//texture.anisotropy = 16;

	//color.setRGB(objects[i][3][0],objects[i][3][1],objects[i][3][2]); 			
	//var material = new THREE.MeshLambertMaterial({color: color });
	//var material = new THREE.MeshPhongMaterial( { color: objects[i][3] , specular: 0x009900, shininess: 30, shading: THREE.FlatShading } )
	//var color = new THREE.Color().setRGB(1,0,0); 
	//var material = new THREE.MeshPhongMaterial( { shading: THREE.SmoothShading, vertexColors: THREE.VertexColors , side: THREE.DoubleSide} )
	//var material = new THREE.MeshPhongMaterial( { color: 0xff0000 , specular: 0x009900, shininess: 0, shading: THREE.SmoothShading } )

	// --------------------------------------------------------
	// Generate a hashed string
	// --------------------------------------------------------
	var makeId = function() {
		var text = "";
		var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		for( var i=0; i < 5; i++ )
		text += possible.charAt(Math.floor(Math.random() * possible.length));
		return text;
	};
	
	//var myWorker = new Worker("scripts/makertron_worker.js?hash="+makeId()); 

	// =====================================================================================
	// Take all our THREE buffer data paseed over as arrays and convert back to objects. 
	// Note that we take the position -and- the quartnerion to get it back to where it should
	// be in the scene. Not the most efficient but workable for now. 
	// =====================================================================================	
	var objectGenerate = function(objects) { // do the buffer conversion 

		var i = 0;
		var converted = []
		
		//var material = new THREE.MeshLambertMaterial( { map: texture , side: THREE.DoubleSide } );	
		var material = new THREE.MeshPhongMaterial( { color: Math.random() * 0xffffff , specular: 0x009900, shininess: 0, shading: THREE.SmoothShading } )

		var objects_length = objects.length 
		for ( i = 0; i < objects_length; i++ ) {
			var geometry = new THREE.BufferGeometry();
			geometry.fromDamien(objects[i][0]) 
			var obj = new THREE.Mesh( geometry , material )
			obj.castShadow = true
			obj.receiveShadow  = true
			obj.position.fromArray( objects[i][1] ) 
			var quat = new THREE.Quaternion().fromArray(objects[i][2]) 
			obj.quaternion.copy( quat ) 
			//obj.geometry.computeFaceNormals()
			obj.geometry.computeVertexNormals() 
			converted.push ( obj ) 
			converted.push( new THREE.EdgesHelper( obj , 0x000000 ) )
		}
		return converted; 
	}
	
	/*var	loadWorker = function(data,callback) { 
		myWorker.postMessage( data );
		myWorker.onmessage = function(e) {
			if ( e.data[0] === "done" ) { // when the worker is finished respond to done event 		
				var chunk = e.data[1];
				var current_meshes = []; 
				chunk.forEach(function(object){
					current_meshes = current_meshes.concat(objectGenerate(object) );  
				});
				callback(current_meshes)    
			}	  
		}		
	}*/


	module.exports = React.createClass({
    displayName: 'ThreeComponent',
		getDefaultProps: function() {
    	return { event : false };
  	},	
		getInitialState: function() {
    	return { meshes: [] };
  	},
		// ============================================================================
		// Setup the orbit control state 
		// ============================================================================
		orbit_init() { 	
			// API
			this.enabled = true;
			this.center = new THREE.Vector3();
			this.userZoom = true;
			this.userZoomSpeed = 1.0;
			this.userRotate = true;
			this.userRotateSpeed = 1.0;
			this.userPan = true;
			this.userPanSpeed = 2.0;
			this.autoRotate = false;
			this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
			this.minPolarAngle = 0; // radians
			this.maxPolarAngle = Math.PI; // radians
			this.minDistance = 0;
			this.maxDistance = Infinity;
			this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
			// internals
			this.scope = this;
			this.EPS = 0.000001;
			this.PIXELS_PER_ROUND = 1800;
			this.rotateStart = new THREE.Vector2();
			this.rotateEnd = new THREE.Vector2();
			this.rotateDelta = new THREE.Vector2();
			this.zoomStart = new THREE.Vector2();
			this.zoomEnd = new THREE.Vector2();
			this.zoomDelta = new THREE.Vector2();
			this.phiDelta = 0;
			this.thetaDelta = 0;
			this.scale = 1;
			this.lastPosition = new THREE.Vector3();
			this.STATE_WTF = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };
			this.state_wtf = this.STATE_WTF.NONE;
			this.lastX = 0; 
			this.lastY = 0;
			// events
			this.changeEvent = { type: 'change' };
		},
		rotateLeft( angle  ) { if ( angle === undefined ) {	angle = this.getAutoRotationAngle(); } this.thetaDelta -= angle; },
		rotateRight( angle ) { if ( angle === undefined ) { angle = this.getAutoRotationAngle(); } this.thetaDelta += angle; },
		rotateUp( angle    ) { if ( angle === undefined ) { angle = this.getAutoRotationAngle(); } this.phiDelta -= angle;   },
		rotateDown( angle  ) { if ( angle === undefined ) { angle = this.getAutoRotationAngle(); } this.phiDelta += angle;   },
		zoomIn( zoomScale  ) { if ( zoomScale === undefined ) { zoomScale = this.getZoomScale(); } this.scale /= zoomScale;  },
		zoomOut( zoomScale ) { if ( zoomScale === undefined ) { zoomScale = this.getZoomScale(); } this.scale *= zoomScale;  },
		pan( distance ) {
			distance.transformDirection( this.camera.matrix );
			distance.multiplyScalar( this.userPanSpeed );
			this.camera.position.add( distance );
			this.center.add( distance );
		},
		getAutoRotationAngle() { return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed; },
		getZoomScale() { return Math.pow( 0.95, this.userZoomSpeed ); },
		// ===========================================================
		// update orbit control
		// ===========================================================
		orbit_update() {
			var position = this.camera.position;
			var offset = position.clone().sub( this.center );
			// angle from z-axis around y-axis
			var theta = Math.atan2( offset.x, offset.z );
			// angle from y-axis
			var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );
			if ( this.autoRotate ) {
				this.rotateLeft( this.getAutoRotationAngle() );
			}
			theta += this.thetaDelta;
			phi += this.phiDelta;
			// restrict phi to be between desired limits
			phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );
			// restrict phi to be betwee EPS and PI-EPS
			phi = Math.max( this.EPS, Math.min( Math.PI - this.EPS, phi ) );
			var radius = offset.length() * this.scale;
			// restrict radius to be between desired limits
			radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );
			offset.x = radius * Math.sin( phi ) * Math.sin( theta );
			offset.y = radius * Math.cos( phi );
			offset.z = radius * Math.sin( phi ) * Math.cos( theta );
			position.copy( this.center ).add( offset );
			this.camera.lookAt( this.center );
			this.thetaDelta = 0;
			this.phiDelta = 0;
			this.scale = 1;
			if ( this.lastPosition.distanceTo( this.camera.position ) > 0 ) {
				this.lastPosition.copy( this.camera.position );
			}
			this.render_scene()
		},
		onMouseMove(event) {
    	if ( this.enabled === false ) return;
			if ( this.state_wtf === this.STATE_WTF.ROTATE ) {
				this.rotateEnd.set( event.clientX, event.clientY );
				this.rotateDelta.subVectors( this.rotateEnd, this.rotateStart );
				this.rotateLeft( 2 * Math.PI * this.rotateDelta.x / this.PIXELS_PER_ROUND * this.userRotateSpeed );
				this.rotateUp( 2 * Math.PI * this.rotateDelta.y / this.PIXELS_PER_ROUND * this.userRotateSpeed );
				this.rotateStart.copy( this.rotateEnd );
				this.orbit_update()
			} else if ( this.state_wtf === this.STATE_WTF.ZOOM ) {
				this.zoomEnd.set( event.clientX, event.clientY );
				this.zoomDelta.subVectors( this.zoomEnd, this.zoomStart );
				if ( this.zoomDelta.y > 0 ) {
					this.zoomIn();
					this.orbit_update()
				} else {
					this.zoomOut();
					this.orbit_update()
				}
				this.zoomStart.copy( this.zoomEnd );
			} else if ( this.state_wtf === this.STATE_WTF.PAN ) {
				var movementX = event.clientX + this.lastX
				var movementY = event.clientY + this.lastY 
				//var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
				//var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
				//console.log( movementX , movementY ) 
				this.pan( new THREE.Vector3( - movementX, movementY, 0 ) );
				this.orbit_update()
				this.lastX = movementX
				this.lastY = movementY  
			}
  	},
		onMouseDown(event) {
    	if ( this.enabled === false ) return;
			if ( this.userRotate === false ) return;
			if ( event.button === 0 ) {
				this.state_wtf = this.STATE_WTF.ROTATE;
				this.rotateStart.set( event.clientX, event.clientY );
			} else if ( event.button === 1 ) {
					this.state_wtf = this.STATE_WTF.ZOOM;
					this.zoomStart.set( event.clientX, event.clientY );
			} else if ( event.button === 2 ) {
					this.state_wtf = this.STATE_WTF.PAN;
			}
  	},
		onMouseUp(event) {
			if ( this.enabled === false ) return;
			if ( this.userRotate === false ) return;
			this.state_wtf = this.STATE_WTF.NONE;
		},
		onMouseWheel( event ) {
			event.preventDefault()
			if ( this.enabled === false ) return;
			if ( this.userZoom === false ) return;
			if ( event.deltaY < 0 ) {
				this.zoomOut();
				this.orbit_update()
			} else {
				this.zoomIn();
				this.orbit_update()
			}
		},
		onTouchStart(event) { 
			if ( this.enabled === false ) return;
			if ( this.userRotate === false ) return;
			this.state_wtf = this.STATE_WTF.ROTATE;
			this.rotateStart.set( event.touches[0].clientX, event.touches[0].clientY );
		},
		onTouchEnd(event) { 
			if ( this.enabled === false ) return;
			if ( this.userRotate === false ) return;
			this.state_wtf = this.STATE_WTF.NONE;
		},
		onTouchMove(event) { 
			event.preventDefault()
			if ( this.enabled === false ) return;
			if ( this.state_wtf === this.STATE_WTF.ROTATE ) {
				this.rotateEnd.set( event.touches[0].clientX, event.touches[0].clientY );
				this.rotateDelta.subVectors( this.rotateEnd, this.rotateStart );
				this.rotateLeft( 2 * Math.PI * this.rotateDelta.x / this.PIXELS_PER_ROUND * this.userRotateSpeed );
				this.rotateUp( 2 * Math.PI * this.rotateDelta.y / this.PIXELS_PER_ROUND * this.userRotateSpeed );
				this.rotateStart.copy( this.rotateEnd );
				this.orbit_update()
			} 
		}, 
		init_scene() {
			this.container = document.getElementById("three_canvas");
			this.width = this.container.clientWidth; 
			this.height = this.container.clientHeight; 
			this.renderer = new THREE.WebGLRenderer( { antialias: true , alpha: true } );
			this.renderer.setSize( this.width, this.height );
			this.renderer.sortObjects = true;
			this.renderer.setClearColor( 0xff0000 , 0); // the default
			this.renderer.shadowMap.enabled = true;
			this.camera = new THREE.PerspectiveCamera( 45 , this.width / this.height, 1, 10000 );
			this.camera.position.set( 0,0 , 400 ); 
			this.camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
			this.orbit_init()
			//this.controls = new THREE.OrbitControls( this.camera , this.container);				
			this.scene = new THREE.Scene(); 	
			//this.camera.lookAt(this.scene.position);				
			this.container.appendChild( this.renderer.domElement ); // bind to the container element 
		},
		resize_scene() { 
			var container = document.getElementById("three_canvas");
			var width = container.clientWidth; 
			var height = container.clientHeight; 
			this.renderer.setSize( width , height );
			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();
		},
		render_scene() { // Render out to canvas 
			this.resize_scene(); 
			this.renderer.render( this.scene, this.camera );
		},
		lights () { 
			this.scene.add( new THREE.AmbientLight( 0xe0e0e0 ) );
			
			var back_light = new THREE.SpotLight( 0x0000ff, 1.5 );
			back_light.position.set( 0, 0, -500 );
			back_light.castShadow = true;
			back_light.shadow.camera.near = 200;
			back_light.shadow.camera.far = this.camera.far;
			back_light.shadow.camera.fov = 50;
			back_light.shadow.bias = -0.00022;
			back_light.shadow.darkness = 0.5;
			//back_light.shadow.map.width = 2048;
			this.scene.add(back_light);	
		
			var front_light = new THREE.SpotLight( 0x00ff00, 1.5 );
			front_light.position.set( 0, 0, 500 );
			front_light.castShadow = true;
			front_light.shadow.camera.near = 200;
			front_light.shadow.camera.far = this.camera.far;
			front_light.shadow.camera.fov = 50;
			front_light.shadow.bias = -0.00022;
			front_light.shadow.darkness = 0.5;
			//front_light.shadow.map.width = 2048;
			this.scene.add(front_light);	
	
		},
		radians (deg) { 
			return deg * (Math.PI / 180); 
		} , 
		update_scene() { 	
			var _this = this
			// Scene defaults
			this.scene = new THREE.Scene(); 
			this.lights(); 		
			var axisHelper = new THREE.AxisHelper( 400 );
			this.scene.add( axisHelper );
			var geometry = new THREE.PlaneGeometry( 400, 400 );
			var material = new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color: 0x0000ff, transparent: true, opacity: 0.5});
			var plane = new THREE.Mesh( geometry, material );
			plane.receiveShadow  = true;
			plane.rotation.set( this.radians(90) , 0, 0 )
			plane.position.set( 0 , -100 , 0 );  
			this.scene.add( plane );
						
			var myWorker = new Worker("scripts/makertron_worker.js?hash="+makeId()); 
			myWorker.postMessage( this.props.data );
			myWorker.onmessage = function(e) {			
				if ( e.data[0] === "done" ) { // when the worker is finished respond to done event 	
					var i = 0; 
					var chunk = e.data[1];
					var current_meshes = []; 
					chunk.forEach(function(object){
						current_meshes = current_meshes.concat(objectGenerate(object) );  
					});  
					var current_meshes_length = current_meshes.length;
					if ( current_meshes_length != 0 ) { 
						for ( i = 0; i < current_meshes_length; i++ ) { 
							_this.scene.add(current_meshes[i]); 
						} 
					}
					_this.render_scene()	  
				}
				if ( e.data[0] === "console" ) { 
					//console.log( "log" , e.data[1] )
					_this.props.patronus.updateLog( e.data[1] )
				}
			}			
		},
		//refreshMeshes(meshes) {
		//	this.setState({meshes:meshes}) 
		//},
		componentWillMount() { 
		},
		componentDidMount() { 
			this.init_scene()
			this.update_scene() 			
			this.orbit_update()
		},
		componentDidUpdate() { 	
			console.log("updating")
			this.update_scene() 			
			this.orbit_update()
		}, 
		render() {
    	return (
      	<div 
							id="three_canvas" 
							style={{'width': canvas_width ,'height':'80vh','background':dark_primary_color}}  
							onMouseMove={this.onMouseMove}
							onMouseDown={this.onMouseDown}
							onMouseUp={this.onMouseUp}
							onWheel={this.onMouseWheel}
							onTouchMove={this.onTouchMove}
							onTouchStart={this.onTouchStart}
							onTouchEnd={this.onTouchEnd}
						></div>
    	)
  	}
	}); 
